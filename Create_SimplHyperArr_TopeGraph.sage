import ast
import sqlite3
def ConstructGraph(Arrangement, d): #Constructs the tope graph of a simplicial hyperplane arrangement
    #Arrangement is a list of normal vectors and d is the rank of the arrangement
    def first_chamber(Arrlist): #Constructs one chamber of the simplicial arrangement
        # Change the normal vectors to positive system
        t = randint(2,30)
        dimen = len(Arrlist[0])
        n = len(Arrlist)
        HyperNor = []
        m = d**20
        for v in Arrlist:
            HyperNor.append(vector(v))
        c = vector([t^k for k in [1..dimen]])
        for j in [0..len(HyperNor)-1]:
            tempvalue = c.dot_product(HyperNor[j])
            if tempvalue < 0:
                HyperNor[j] = (-1)*HyperNor[j]
        Arrlist = HyperNor
        # find chamber vectors by inductively reducing the rank
        Cham = []
        Listvec = []
        Rest = [0..n-1]
        for v in Arrlist:
            Listvec.append((vector(v)*(1/c.dot_product(vector(v)))))
        t = randint(t+1,2*t)
        w = vector([t^k for k in [1..dimen]])
        maxwert = -oo
        maxvec = 0
        for k in [0..n-1]:
            tempvalue = w.dot_product(vector(Listvec[k]))
            if tempvalue > maxwert:
                maxvec = k
                maxwert = tempvalue
        Cham.append(maxvec)
        maxvector = Listvec[maxvec]
        Listvec = Listvec[:maxvec] + Listvec[maxvec+1:]
        Rest = Rest[:maxvec] + Rest[maxvec+1:]
        for i in [1..d-1]:
            ListvecTemp = []
            RestTemp = []
            maxent = -oo
            t = randint(2,30)
            neuw = vector([t^k*randint(2,30) for k in [1..dimen]])

            it = len(Rest)
            for v in [0..it-1]:
                factor = (m/(-w).dot_product(Listvec[v]-maxvector))
                testvec = (Listvec[v]-maxvector)*factor
                tempvalue = neuw.dot_product(testvec)
                if testvec in ListvecTemp:
                    ind = ListvecTemp.index(testvec)
                    if factor < RestTemp[ind][0]:
                        RestTemp[ind] = [factor,Rest[v]]
                        if tempvalue == maxent:
                            newVertexIndex = Rest[v]
                else:
                    ListvecTemp.append(testvec)
                    RestTemp.append([factor,Rest[v]])
                    if tempvalue > maxent:
                        maxent = tempvalue
                        newVertexIndex = Rest[v]
                        newVertex = testvec
            w = neuw
            Cham.append(newVertexIndex)
            maxvector = newVertex
            Rest = []
            for v in [0..len(RestTemp)-1]:
                if RestTemp[v][1] == newVertexIndex:
                    ListvecTemp = ListvecTemp[:v] + ListvecTemp[v+1:]
                else:
                    Rest.append(RestTemp[v][1])
            Listvec = ListvecTemp.copy()
        Chamber=(tuple(len(HyperNor)*[1]),tuple(Cham))
        # Chamber is a tope of the chamber and a list of wallindexe
        # HyperNor is the list of the positive system
        Out=(Chamber,HyperNor)
        return Out
    def stdbasetransformation(normals_list, d_indices): # Takes a positive system and a list of generating vectors in the system
                                                        # and does a basis change to the unit vectors on the system
        Ring = QQ
        dimen = len(normals_list[0])
        for v in normals_list:
            if vector(v).base_ring() != ZZ:
                Ring = vector(v).base_ring()
        Rows = [normals_list[i] for i in d_indices]
        for i in [len(Rows)+1 .. dimen]:
            Rows.append(vector([random() for t in [1..dimen]]))
        basechangematrix = matrix(Ring,Rows).transpose().inverse()
        basechangematrix = basechangematrix[:d]
        transformed_normals_list = []
        for index in range(len(normals_list)):
            transformed_normals_list += [basechangematrix*vector(Ring,normals_list[index])]
        # transformed_normalls_list is the positive system generated by unit vectors
        return transformed_normals_list
    def ChamberMove(Chamber, Wall, Matrix): # Given a chamber via a tope and a list of walls, a Wall of that chamber,
                                            # and the positive system as a list generated by unit vectors in Matrix
                                            # generates the neighbor chamber adjacent to Wall
        Signs, Facet = Chamber
        Wall1 = Matrix[Wall]
        NewChamberSign = [i for i in Signs]
        NewChamberSign[Wall] = -1*NewChamberSign[Wall]
        NewChamberSign = tuple(NewChamberSign)
        NewChamberFacet = [Wall]
        Transform = []
        # Takes a pair of a separating wall root and a other wall and generates the new walls for the neighboring chamber
        for i in range(d):
            if Wall1[i] == 1:
                Wall1Index = i
        for ind in Facet:
            if ind != Wall:
                Wall2 = Matrix[ind]
                for j in range(d):
                    if Wall2[j] == 1:
                        Wall2Index = j
                TestVec = vector([1]*d)
                TestVec[Wall1Index] = 0
                TestVec[Wall2Index] = 0
                NewWallList = []
                for k in [0..len(Matrix)-1]:
                    if Matrix[k].dot_product(TestVec) == 0 and Matrix[k][Wall1Index] > 0 and Matrix[k][Wall2Index] > 0:
                        NewWallList.append([k,Matrix[k]])
                if len(NewWallList) == 0:
                    NewChamberFacet.append(ind)
                else:
                    MaxEnt = -oo
                    MaxIndex = 0
                    for h in NewWallList:
                        AbNow = h[1][Wall1Index]/h[1][Wall2Index]
                        if AbNow > MaxEnt:
                            MaxEnt = AbNow
                            MaxIndex = h[0]
                            NewWall2 = h[1]
                    NewChamberFacet.append(MaxIndex)
                    Transform.append([Wall2Index,MaxEnt,NewWall2[Wall2Index]])
        # NewMatrix is the list of positive roots generated by unit vectors for the newly generated chamber
        NewMatrix = deepcopy(Matrix)
        for i in [0..len(NewMatrix)-1]:
            if i != Wall:
                NewMatrix[i][Wall1Index] = -NewMatrix[i][Wall1Index]
            for t in Transform:
                NewMatrix[i][Wall1Index] = NewMatrix[i][Wall1Index]+t[1]*NewMatrix[i][t[0]]
                NewMatrix[i][t[0]]=  NewMatrix[i][t[0]]/t[2]
        NewChamberFacet.sort()
        NewChamber = (NewChamberSign, tuple(NewChamberFacet))
        # Chamber is the chamber we came from
        # NewChamber is the new chamber via a tope and a list of walls
        # Wall is the wall separating Chamber and NewChamber
        # For NewMatrix see above 
        return Chamber, NewChamber, Wall, NewMatrix
    G = Graph()
    # Create a stack of still to check chambers with walls
    UnvisitedChambers = list()
    # Create the first chamber
    FirstChamber, PosSys = first_chamber(Arrangement)
    G.add_vertex(FirstChamber[0])
    M = stdbasetransformation(PosSys, FirstChamber[1])
    UnvisitedChambers.append([FirstChamber,list(FirstChamber[1]),deepcopy(M)])
    del M
    Numb = 0
    # While there are still chambers to check the adjacent walls of create a the neighboring chamber and connect them
    while len(UnvisitedChambers) > 0:
        Chamber, Neighbors, Mcurrent = UnvisitedChambers.pop()
        Neighbor = Neighbors.pop()
        Seen = False
        for e in G.edges(vertices=[Chamber[0]]):
            if e[2] == Neighbor:
                Seen = True
        if not Seen:
            X = ChamberMove(Chamber, Neighbor, Mcurrent)
            NewChamber = X[1]
            if not G.has_vertex(X[1][0]):
                Numb = Numb + 1
                G.add_vertex(X[1][0])
                G.add_edge(Chamber[0], X[1][0], Neighbor)
                Walls = [i for i in X[1][1] if i != Neighbor]
                UnvisitedChambers.append([NewChamber,Walls,X[3]])
            else:
                G.add_edge(Chamber[0], X[1][0], Neighbor)
        if len(Neighbors) > 0:
            UnvisitedChambers.append([Chamber,Neighbors,deepcopy(Mcurrent)])
        else:
            del Mcurrent
        # Progress print
        if Numb%20000 == 0:
            print(Numb, "many vertices created.")
    return G, PosSys


def save_graph_txt(Name, Normals, d): # Constructs a graph and saves as txt file
    arr = []
    for h in Normals:
        arr.append(vector(h))
    Gneu, PosSys = ConstructGraph(arr,d)
    Name = Name + ".txt"
    f = open(Name, "w")
    f.write(str(Gneu.edges()))
    f.write("\n")
    f.write(str(PosSys))
    f.close()
    print("Written " + Name)

def save_graph_sql(Name, Normals, d): # Constructs a graph and saves as db sql file using sqlite3
    print("Write database")
    arr = []
    for h in Normals:
        arr.append(vector(h))
    Gneu, PosSys = ConstructGraph(arr,d)
    dbname = Name + ".db"
    connection = sqlite3.connect(dbname)
    cursor = connection.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS vertices (id INTEGER, name TEXT)")
    cursor.execute("CREATE TABLE IF NOT EXISTS edges (id INTEGER, idfirstvertex INTEGER, idsecondvertex INTEGER)")
    cursor.execute("CREATE TABLE IF NOT EXISTS possys (id INTEGER, name TEXT)")
    print("Write vertices")
    id = 0
    for vertex in Gneu.vertices():
        vertex = str(vertex)
        sqlanfrage = "INSERT INTO vertices VALUES (" + str(id)+", \'" + vertex+"\')"
        cursor.execute(sqlanfrage)
        id += 1
        if id % 10000 == 0:
            connection.commit()
            print(str(id),"many vertices written")
    connection.commit()
    print("vertices written")
    print("Write edges")
    edgeid = 0
    for edge in Gneu.edges():
        Knoten1, Knoten2 = edge[0], edge[1]
        sqlanfrage ="SELECT * FROM vertices WHERE name = \'"+str(Knoten1)+"\'"
        cursor.execute(sqlanfrage)
        rows = cursor.fetchall()
        Knoten1id = rows[0][0]
        sqlanfrage ="SELECT * FROM vertices WHERE name = \'"+str(Knoten2)+"\'"
        cursor.execute(sqlanfrage)
        rows = cursor.fetchall()
        Knoten2id = rows[0][0]
        sqlanfrage = "INSERT INTO edges VALUES (" + str(edgeid)+","+str(Knoten1id)+","+str(Knoten2id)+")"
        cursor.execute(sqlanfrage)
        edgeid += 1
        if edgeid % 10000 == 0:
            connection.commit()
            print(str(edgeid),"Edges written")
    connection.commit()
    print("Edges written")
    print("Write positive system")
    possysid = 0
    for vect in PosSys:
        sqlanfrage = "INSERT INTO possys VALUES (" + str(possysid)+", \'" + str(vect)+"\')"
        cursor.execute(sqlanfrage)
        possysid += 1
    connection.commit()
    connection.close()
    print("Finished writing")
    print("Written " + Name)

def graph_from_txt(Name):
    f = open(Name, "r")
    line = f.readlines()[0]
    f.close()
    Edges = ast.literal_eval(line)
    G = Graph(Edges)
    return G


def graph_from_sql(Name): # Reads sqlite3 db file and creates the graph from it
    dbname = Name + ".db"
    connection = sqlite3.connect(dbname)
    print("Database connected")
    cursor = connection.cursor()
    print("Access generated")
    cursor.execute("SELECT * FROM edges")
    print("Access successfuly")
    rows = cursor.fetchall()
    Edges = list()
    print("Create edgelist")
    for row in rows:
        newrow = [row[1], row[2]]
        Edges.append(newrow)
    print("Disconnect from database")
    connection.close()
    print("Create graph")
    G = Graph(Edges)
    print("Finished")
    return G

def save_graph_sql_from_graphs(Name, Gneu, PosSys): # Saves a graph as db sqlite3 file
    print("Write database")
    dbname = Name + ".db"
    connection = sqlite3.connect(dbname)
    cursor = connection.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS vertices (id INTEGER, name TEXT)")
    cursor.execute("CREATE TABLE IF NOT EXISTS edges (id INTEGER, idfirstvertex INTEGER, idsecondvertex INTEGER)")
    cursor.execute("CREATE TABLE IF NOT EXISTS possys (id INTEGER, name TEXT)")
    print("Write vertices")
    id = 0
    for vertex in Gneu.vertices():
        vertex = str(vertex)
        sqlanfrage = "INSERT INTO vertices VALUES (" + str(id)+", \'" + vertex+"\')"
        cursor.execute(sqlanfrage)
        id += 1
        if id % 10000 == 0:
            connection.commit()
            print(str(id),"vertices written")
    connection.commit()
    print("Write edges")
    edgeid = 0
    for edge in Gneu.edges():
        Knoten1, Knoten2 = edge[0], edge[1]
        sqlanfrage ="SELECT * FROM vertices WHERE name = \'"+str(Knoten1)+"\'"
        cursor.execute(sqlanfrage)
        rows = cursor.fetchall()
        Knoten1id = rows[0][0]
        sqlanfrage ="SELECT * FROM vertices WHERE name = \'"+str(Knoten2)+"\'"
        cursor.execute(sqlanfrage)
        rows = cursor.fetchall()
        Knoten2id = rows[0][0]
        sqlanfrage = "INSERT INTO edges VALUES (" + str(edgeid)+","+str(Knoten1id)+","+str(Knoten2id)+")"
        cursor.execute(sqlanfrage)
        edgeid += 1
        if edgeid % 10000 == 0:
            connection.commit()
            print(str(edgeid),"edges written")
    connection.commit()
    print("Write positive system")
    possysid = 0
    for vect in PosSys:
        sqlanfrage = "INSERT INTO possys VALUES (" + str(possysid)+", \'" + str(vect)+"\')"
        cursor.execute(sqlanfrage)
        possysid += 1
    connection.commit()
    connection.close()
    print("Finished written " + Name)
    
    
def first_chamber(Arrlist): #Constructs one chamber of the simplicial arrangement
    # Change the normal vectors to positive system
    t = randint(2,30)
    dimen = len(Arrlist[0])
    n = len(Arrlist)
    HyperNor = []
    m = d**20
    for v in Arrlist:
        HyperNor.append(vector(v))
    c = vector([t^k for k in [1..dimen]])
    for j in [0..len(HyperNor)-1]:
        tempvalue = c.dot_product(HyperNor[j])
        if tempvalue < 0:
            HyperNor[j] = (-1)*HyperNor[j]
    Arrlist = HyperNor
    # find chamber vectors by inductively reducing the rank
    Cham = []
    Listvec = []
    Rest = [0..n-1]
    for v in Arrlist:
        Listvec.append((vector(v)*(1/c.dot_product(vector(v)))))
    t = randint(t+1,2*t)
    w = vector([t^k for k in [1..dimen]])
    maxwert = -oo
    maxvec = 0
    for k in [0..n-1]:
        tempvalue = w.dot_product(vector(Listvec[k]))
        if tempvalue > maxwert:
            maxvec = k
            maxwert = tempvalue
    Cham.append(maxvec)
    maxvector = Listvec[maxvec]
    Listvec = Listvec[:maxvec] + Listvec[maxvec+1:]
    Rest = Rest[:maxvec] + Rest[maxvec+1:]
    for i in [1..d-1]:
        ListvecTemp = []
        RestTemp = []
        maxent = -oo
        t = randint(2,30)
        neuw = vector([t^k*randint(2,30) for k in [1..dimen]])

        it = len(Rest)
        for v in [0..it-1]:
            factor = (m/(-w).dot_product(Listvec[v]-maxvector))
            testvec = (Listvec[v]-maxvector)*factor
            tempvalue = neuw.dot_product(testvec)
            if testvec in ListvecTemp:
                ind = ListvecTemp.index(testvec)
                if factor < RestTemp[ind][0]:
                    RestTemp[ind] = [factor,Rest[v]]
                    if tempvalue == maxent:
                        newVertexIndex = Rest[v]
            else:
                ListvecTemp.append(testvec)
                RestTemp.append([factor,Rest[v]])
                if tempvalue > maxent:
                    maxent = tempvalue
                    newVertexIndex = Rest[v]
                    newVertex = testvec
        w = neuw
        Cham.append(newVertexIndex)
        maxvector = newVertex
        Rest = []
        for v in [0..len(RestTemp)-1]:
            if RestTemp[v][1] == newVertexIndex:
                ListvecTemp = ListvecTemp[:v] + ListvecTemp[v+1:]
            else:
                Rest.append(RestTemp[v][1])
        Listvec = ListvecTemp.copy()
    Chamber=(tuple(len(HyperNor)*[1]),tuple(Cham))
    # Chamber is a tope of the chamber and a list of wallindexe
    # HyperNor is the list of the positive system
    Out=(Chamber,HyperNor)
    return Out

